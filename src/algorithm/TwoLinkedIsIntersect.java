package algorithm;

/**
 * Author :  suzeyu
 * Time   :  2016-11-12  下午11:01
 * Blog   :  http://szysky.com
 * GitHub :  https://github.com/suzeyu1992
 *
 * ClassDescription :
 *
 *              问题: 判断两个链表是否相交?
 *
 *              解法1: 最简单的的想法, 遍历第一个链表的的每一个节点, 是否存在第二个链表上?
 *                    虽然简单, 但是时间复杂度等于 O(链表1的长度 * 链表2的长度)
 *
 *              解法2: 利用计数的方法.
 *                     通过节点的地址唯一标识的特点来判断. 对链表1的节点hash排序, 建立hash表
 *                     . 然后针对第二个链表的每个节点的地址查询hash表, 如果在hash表中出现. 说明有共同节点
 *                     时间复杂度为 O(1长度 + 链表2长度), 但是需要附加一个O(链表1)的存储空间
 *
 *              解法3: 转换思想: 由于两个链表都没有环, 可以把链表2接到链表1的后面. 如果得到链表环,那么就相交.
 *                      链表环的只需要从链表2的头部遍历,看看是否能重新回到链表2的头部节点. 并在最后去掉第一个链表
 *                      的指向
 *
 *              解法4: 抓住要点: 如果两个链表相交, 那么从相交点到最后的节点都是共享的. 那么我们就可以判断两个链表
 *                          最后一个节点是否相同. 这样时间复杂度只是一个线性O(链表1长+链表2). 也不需要很多的额外空间
 *
 *
 */
public class TwoLinkedIsIntersect {
}
